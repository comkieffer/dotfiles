#!/usr/bin/env python

import argparse
import os
import string
import subprocess
import sys
import re
from pathlib import Path
from contextlib import suppress
from dataclasses import dataclass
from typing import Self
from functools import lru_cache
from collections import defaultdict

# Detect if rich is available
try:
	from rich.panel import Panel
	from rich.console import Console
	from rich.text import Text
	from rich.rule import Rule
except ImportError:
	# If rich is not available, use these simpler classes instead.

	def _strip_markup(text: str) -> str:
		"""Remove rich markup tags from text."""
		return re.sub(r'\[/?[^\]]+\]', '', text)

	class Console:
		def __init__(self, stderr=False):
			self.file = sys.stderr if stderr else sys.stdout

		def print(self, *args, **kwargs):
			text = ' '.join(_strip_markup(str(arg)) for arg in args)
			print(text, file=kwargs.get('file', self.file))

	class Text:
		def __init__(self):
			self.parts = []

		def append(self, text, style=None):
			self.parts.append(str(text))

		def __str__(self):
			return ''.join(_strip_markup(p) for p in self.parts)

	class Panel:
		def __init__(self, content, title=None, border_style=None):
			self.content = str(content)
			self.title = title

		def __str__(self):
			lines = []
			if self.title:
				lines.append(f"=== {self.title} ===")
			lines.append(_strip_markup(self.content))
			lines.append("=" * 40)
			return '\n'.join(lines)

	class Rule:
		def __init__(self, title=None):
			self.title = title

		def __str__(self):
			return f"--- {self.title} ---\n" if self.title else "-" * 40


@dataclass
class ToDoItem:
	text: str
	project_path: Path
	section: str | None = None

	@property
	def project(self) -> str:
		return self.project_path.name

def parse_args() -> argparse.Namespace:
	"""Parse command line arguments.

	Returns:
		Parsed arguments including subcommand and options.
	"""
	parser = argparse.ArgumentParser(
		description="Find and display TODO items from ToDo.md files"
	)
	parser.add_argument(
		"-d", "--root-dir",
		default=".",
		type=Path,
		help="Root directory to search for ToDo.md files (default: current directory)"
	)

	subparsers = parser.add_subparsers(dest="command", help="Available commands")

	# List subcommand (default)
	subparsers.add_parser("list", help="List all TODO items")

	# Edit subcommand
	edit_parser = subparsers.add_parser("edit", help="Open a project's ToDo.md file in editor")
	edit_parser.add_argument(
		"project",
		help="Project name (case-insensitive) or '.' for current project"
	)

	args = parser.parse_args()

	# Default to list command if no subcommand specified
	if args.command is None:
		args.command = "list"

	return args

def run(command: list[str]) -> str | None:
	"""Execute a shell command and handle errors.

	On failure, prints error details to stderr and continues execution.

	Args:
		command: Command and arguments to execute.

	Returns:
		Command stdout if successful, None if command failed.
	"""
	retval = subprocess.run(command, text=True, capture_output=True)

	if retval.returncode != 0:
		console = Console(stderr=True)
		panel_content = Text()
		panel_content.append(f"Command: {' '.join(command)}\n", style="bold")
		panel_content.append(f"Return code: {retval.returncode}\n\n", style="bold red")

		if retval.stdout:
			panel_content.append(Rule(title="stdout"))
			panel_content.append(retval.stdout)

		if retval.stderr:
			panel_content.append(Rule(title="stderr"))
			panel_content.append(retval.stderr)

		console.print(Panel(panel_content, title=f"Command Returned {retval.returncode}", border_style="red"))
		return None

	return retval.stdout

def find_todo_files(root_dir: Path) -> list[Path]:
	"""Find all ToDo.md files recursively in the given directory.

	Skips files in directories containing "_archived" in their path.

	Args:
		root_dir: Directory to search from.

	Returns:
		List of paths to ToDo.md files.
	"""
	output = run(["fd", "-t", "f", "-i", "ToDo.md", str(root_dir)])
	if output is None:
		return []
	files = [Path(f) for f in output.splitlines() if len(f) > 0]
	# Filter out archived directories
	return [f for f in files if "_archived" not in str(f)]


def extract_todo_entries(file: Path) -> list[ToDoItem]:
	"""Extract unchecked top-level todo items from a markdown file.

	Only includes checkboxes that are not children of other checkboxes.
	Checked items (- [x]) are excluded. Tracks section headers and associates
	them with todo items.

	Args:
		file: Path to the ToDo.md file.

	Returns:
		List of ToDoItem objects.
	"""
	project_path = find_project_path(file)
	todo_items = []

	try:
		with open(file, 'r') as f:
			lines = f.readlines()
	except Exception as e:
		console = Console(stderr=True)
		console.print(f"[red]Error reading {file}: {e}[/red]")
		return []

	# Regex to match markdown headings at any level
	heading_pattern = re.compile(r'''
		^            # Start of line
		(\#{1,6})    # Group 1: One to six hash symbols
		\s+          # Whitespace
		(.+)         # Group 2: Heading text
		$            # End of line
	''', re.VERBOSE)

	# Regex to match markdown checkboxes: - [ ] or - [x]
	checkbox_pattern = re.compile(r'''
		^           # Start of line
		(\s*)       # Group 1: Leading whitespace (indentation)
		-\ \[       # Literal "- ["
		([ xX])     # Group 2: Checkbox state (space, x, or X)
		\]\ 	    # Literal "] "
		(.+)        # Group 3: Todo text (rest of line)
		$           # End of line
	''', re.VERBOSE)

	# We only care about ToDo entries that are not children of other ToDo entries.
	# Instead of using a proper Markdown parser, we track the indentation of the
	# first checkbox we find, and only include checkboxes at that same level or less.
	min_indent = None
	current_section = None

	for line in lines:
		# Check if line is a heading
		heading_match = heading_pattern.match(line)
		if heading_match:
			current_section = heading_match.group(2).strip()
			continue

		# Check if line is a checkbox
		match = checkbox_pattern.match(line)
		if match:
			# Convert tabs to 4 spaces, then measure indentation level
			indent = match.group(1)
			indentation_level = len(indent.replace('\t', '    '))
			checked = match.group(2).lower() == 'x'
			text = match.group(3).strip()

			# Skip completed items
			if checked:
				continue

			# First checkbox sets the baseline for top-level indentation
			if min_indent is None:
				min_indent = indentation_level

			# Only include checkboxes at or before the minimum indent (top-level items)
			if indentation_level <= min_indent:
				todo_items.append(ToDoItem(text=text, project_path=project_path, section=current_section))

	return todo_items


@lru_cache
def find_project_path(file: Path) -> Path:
	"""Find the project root path for a file.

	Uses git repository root if in a git repo, otherwise the parent directory.

	Args:
		file: Path to file or directory.

	Returns:
		Project root path.
	"""
	file_dir = file.parent if file.is_file() else file

	result = subprocess.run(
		["git", "-C", str(file_dir), "rev-parse", "--show-toplevel"],
		capture_output=True,
		text=True
	)

	if result.returncode == 0:
		return Path(result.stdout.strip())

	return file_dir

def path_with_tilde(path: Path) -> str:
	"""Convert a path to use ~ for home directory.

	Args:
		path: Path to convert.

	Returns:
		String representation with ~ if under home directory.
	"""
	try:
		home = Path.home()
		return f"~/{path.relative_to(home)}"
	except ValueError:
		return str(path)

def to_title_case(msg: str) -> str:
	return string.capwords(msg.replace('-', ' ').replace('_', ' '))


def find_todo_file_for(project_name: str, root_dir: Path) -> Path:
	"""Find the ToDo.md file for a project by name (case-insensitive).

	Args:
		project_name: Project name to search for (case-insensitive).
		root_dir: Root directory to search from.

	Returns:
		Path to the project's ToDo.md file.

	Raises:
		ValueError: If no matching project or multiple matches found.
	"""
	todo_files = find_todo_files(root_dir)
	matches = []

	for file in todo_files:
		project = find_project_path(file).name
		if project.lower() == project_name.lower():
			matches.append(file)

	if len(matches) == 0:
		raise ValueError(f"No project found matching '{project_name}'")
	elif len(matches) > 1:
		raise ValueError(f"Multiple projects found matching '{project_name}': {[str(f) for f in matches]}")

	return matches[0]


def open_in_editor(file: Path) -> None:
	"""Open a file in the default editor.

	Args:
		file: Path to file to open.
	"""
	editor = os.environ.get('EDITOR', 'nano')
	subprocess.run([editor, str(file)])


def main():
	"""Main entry point. Find and display todos grouped by project."""
	args = parse_args()
	console = Console()

	if args.command == "edit":
		try:
			# Handle '.' as current project
			project_name = args.project
			if project_name == ".":
				project_name = find_project_path(Path.cwd()).name

			todo_file = find_todo_file_for(project_name, args.root_dir)
			open_in_editor(todo_file)
		except ValueError as e:
			console.print(f"[red]Error: {e}[/red]", stderr=True)
			sys.exit(1)
	else:  # list command
		todo_files = find_todo_files(args.root_dir)

		todo_items = []
		for file in todo_files:
			todo_items.extend(extract_todo_entries(file))

		if not todo_items:
			console.print("[dim]No todo items found[/dim]")
			return

		# Group by project, then by section within each project
		by_project = defaultdict(lambda: defaultdict(list))
		project_paths = {}
		for item in todo_items:
			by_project[item.project][item.section].append(item.text)
			project_paths[item.project] = item.project_path

		# Print ToDo items
		for project in sorted(by_project.keys()):
			project_path = path_with_tilde(project_paths[project])
			console.print(f"\n  [bold cyan]{to_title_case(project)}[/bold cyan]    [dim]{project_path}[/dim]")

			sections = by_project[project]
			# Show items without a section first (directly under project)
			if None in sections:
				for todo in sections[None]:
					console.print(f"    • {todo}")

			# Show items grouped by section
			for section in sorted([s for s in sections.keys() if s is not None]):
				console.print(f"    [yellow]{section}[/yellow]")
				for todo in sections[section]:
					console.print(f"      • {todo}")

if __name__ == "__main__":
	with suppress(KeyboardInterrupt):
		main()
