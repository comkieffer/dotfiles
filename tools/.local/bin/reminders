#!/usr/bin/env python3

"""
Motd of the local user.

Show messages stored in XDG_USER_DATA_DIR / reminders. The first non-empty line of the
file is the title, the rest of the file is the reminder body. Empty lines between the
title and the body are ignored. Empty lines in the body are preserved.

If ``rich`` is installed, it is used to print the reminders so rich markup may be used
in the file. `
"""

import argparse
import random
import re
import sys
from contextlib import suppress
from pathlib import Path
from typing import TextIO

try:
    import platformdirs
    HAS_PLATFORMDIRS = True
except ImportError:
    HAS_PLATFORMDIRS = False

try:
    from rich.console import Console
    from rich.padding import Padding
    from rich.panel import Panel

    HAS_RICH = True
except ImportError:
    HAS_RICH = False

PROGNAME = Path(__file__).name

if HAS_PLATFORMDIRS:
    REMINDERS_DIR = platformdirs.user_data_path(PROGNAME)
else:
    REMINDERS_DIR = Path.home() / ".local" / "share" / PROGNAME


def read_non_empty_line(f: TextIO) -> str:
    while line := f.readline():
        if line.strip():
            return line
    return ""

def strip_rich_tags(text: str) -> str:
    """Remove Rich markup tags like [bold], [red], [/bold], etc."""
    return re.sub(r'\[/?[^\]]+\]', '', text)

def parse_args() -> argparse.Namespace:
    """Parse command line arguments.

    Returns:
        Parsed arguments including optional reminder file to display.
    """
    parser = argparse.ArgumentParser(
        description="Display reminder messages from the reminders directory"
    )
    parser.add_argument(
        "file",
        nargs="?",
        help="Specific reminder file to show (optional, shows random if not specified)"
    )
    return parser.parse_args()

def main() -> None:
    args = parse_args()

    if not REMINDERS_DIR.is_dir():
        sys.exit(0)


    reminder_files = [f for f in REMINDERS_DIR.iterdir() if f.is_file()]
    if len(reminder_files) == 0:
        sys.exit(0)

    # Select reminder based on argument or randomly
    if args.file:
        file_as_path = Path(args.file)
        if file_as_path.exists():
            selected_reminder = file_as_path
        else:
            selected_reminder = REMINDERS_DIR / args.file
            if not selected_reminder.is_file():
                print(f"Error: Reminder file '{args.file}' not found", file=sys.stderr)
                sys.exit(1)
    else:
        selected_reminder = random.choice(reminder_files)

    with selected_reminder.open("r") as f:
        reminder_title = read_non_empty_line(f)
        reminder_contents = read_non_empty_line(f) + "\n" + f.read().strip()


    if HAS_RICH:
        console = Console()

        panel = Panel(reminder_contents, title=f"[bold]{reminder_title}[/]", padding=1)
        padded_panel = Padding(panel, (1, 1))
        console.print(padded_panel)
    else:
        clean_title = strip_rich_tags(reminder_title)
        clean_contents = strip_rich_tags(reminder_contents)
        print(clean_title + "\n\n" + clean_contents)

    sys.exit(0)

if __name__ == "__main__":
    with suppress(KeyboardInterrupt):
        main()
