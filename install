#! /usr/bin/env python3

"""
Installer for my dotfiles, provides some porcelain around GNU ``stow`` invocations.

The installer has rules for installing the configurations for different programs. To
extend, or edit the rules, modify the `STOWED_PROGRAMS` dictionary in the source.

By default, a configuration can only be installed if the associated executable is
installed. For example, the `fish` shell configuration will only be installed if the
`fish` binary is available on the PATH.


USAGE:
./install all
./install vim bash

"""

from __future__ import annotations

import argparse
import os
import subprocess
import sys

from os.path import expanduser
from collections.abc import Iterable
from typing import TypedDict


class ProgramConfiguration(TypedDict, total=False):
    # Before intalling a configuration, the tool checks that the associated binary is
    # installed (to not install configurations for things that are not installed). The
    # executable name that is used is the name of the configuration. In some cases, the
    # name of the configuration and the executable are different.
    #
    # For example: the helix editor binary is hx.
    executable: str


    # Directories that should be created before running stow to install the dotfiles.
    #
    # This is useful to ensure that stow creates symlinks to the files inside a
    # diectory and not a symlink to the directory itself.
    #
    # For example: to install the set of fish completions we ship with the dotfiles,
    # we need to ensure that `~/.config/fish/completions/` exists. Otherwise, when we
    # run stow, it will just symlink the completions folder, and all the completions we
    # install will appear in this repository.
    create_dirs: list[str]

    # A series of commands to run after running stow.
    #
    # For example, in fish, we want to update the plugins we install with fisher after
    # we have deployed the configurations so that the actual installed plugins, and the
    # manifest stay in sync.
    post_install: list[str]

STOWED_PROGRAMS: dict[str, ProgramConfiguration] = {
    "bash": {
        "create_dirs": [
            "~/.local/share",
        ],
    },
    "fish": {
        # We use `fisher` to install plugins, this will put the installed functions in
        # `functions`. This is also where we put our own functions. If we do not create
        # the directory, all of the plugin-installed functions will appear in our diff.
        "create_dirs": [
            "~/.config/fish/completions/",
            "~/.config/fish/functions/",
            "~/.local/bin",
        ],
        # Ensure that the list of plugins is up-to-date
        "post-install": [
            "fish -c 'fisher update'"
        ]
    },
    "git": {},
    "gdb": {},
    "helix": {
        "executable": "hx",
    },
    "jrnl": {},
    "matlab": {},
    "vim": {},
    "sublime-text-3": {
        "executable": "subl",
        "create_dirs": [
            "~/.config/sublime-text-3/Packages/User",
        ],
    },
    "sublime-merge": {
        "executable": "smerge",
        "create_dirs": [
            "~/.config/sublime-merge/Packages/User",
        ],
    },
    "regolith": {
        "executable": "regolith-look",
        "create_dirs": [
            "~/.config/regolith3",
        ],
    },
    "tools": {
        # These scripts often depend on uv script mode to run
        "executable": "uv",
    },
}

g_targets_processed: list[str] = []


def is_installed(executable: str) -> bool:
    ret = subprocess.run(
        ["which", executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE
    )
    return not bool(ret.returncode)


def stow(target: str, config: ProgramConfiguration) -> tuple[bool, str, str]:
    global g_targets_processed
    if target in g_targets_processed:
        print(f"    <{target}> already processed, skipping.")
        return True, "", ""

    g_targets_processed.append(target)

    if "create_dirs" in config:
        if not isinstance(config["create_dirs"], Iterable):
            config["create_dirs"] = [config["create_dirs"]]

        for directory in config["create_dirs"]:
            try:
                os.makedirs(expanduser(directory))
            except FileExistsError:
                pass

    if "post-install" in config:
        subprocess.run(config["post-install"], shell=True, check=True)

    # Note: Universal newlines tells python to use the default system encoding for the
    # stdout/stderr messages
    command = ["stow", "--target", expanduser("~"), "--restow", target]
    ret = subprocess.run(
        command,
        text=True,
        capture_output=True
    )

    return not bool(ret.returncode), " ".join(command), ret.stdout + ret.stderr


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description=__doc__ + valid_targets_msg,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        "-f",
        "--force",
        action="store_true",
        help="Install configuration even if the associated executable is not installed",
    )
    parser.add_argument(
        "targets",
        metavar="TARGET",
        choices=[*STOWED_PROGRAMS.keys(), "all"],
        type=str,
        nargs="+",
        help="The configurations to install",
    )
    args = parser.parse_args()

    if "all" in args.targets:
        args.targets = [*STOWED_PROGRAMS.keys()]

    if not is_installed("stow"):
        print("Error: `stow` is not installed. Install `stow` to continue.")
        sys.exit(1)

    for target in args.targets:
        if target in STOWED_PROGRAMS:
            executable_name = STOWED_PROGRAMS[target].get("executable", target)
            if not args.force and not is_installed(executable_name):
                print(
                    f"- Skipping <{target}>, <{executable_name}> is not in $PATH ".ljust(
                        60, "."
                    )
                    + " \033[31mFAIL\033[0m"
                )
                continue

            print(f"- Installing configurations for {target} ".ljust(60, "."), end="")
            ok, command, errmsg = stow(target, STOWED_PROGRAMS[target])
            if not ok:
                print(" \033[31mFAIL\033[0m")
                print(f"Error executing: {command}")
                print(errmsg)
                sys.exit(-1)
            else:
                print(" \033[32mOK\033[0m")
        else:
            print(f"\033[31mERROR\033[0m: unknown target <{target}>.")

    sys.exit(0)
