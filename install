#! /usr/bin/env python3

"""
Installer for my dotfiles, provides some porcelain around GNU ``stow`` invocations.

The installer has rules for installing the configurations for different programs. To
extend, or edit the rules, modify the `STOWED_PROGRAMS` dictionary in the source.

By default, a configuration can only be installed if the associated executable is
installed. For example, the `fish` shell configuration will only be installed if the
`fish` binary is available on the PATH.


USAGE:
./install all
./install vim bash

"""

from __future__ import annotations

import argparse
import subprocess
import sys

from os.path import expanduser
from collections.abc import Iterable
from contextlib import contextmanager
from pathlib import Path
from typing import TYPE_CHECKING, TypedDict

if TYPE_CHECKING:
    from typing import Generator


class ProgramConfiguration(TypedDict, total=False):
    # Before intalling a configuration, the tool checks that the associated binary is
    # installed (to not install configurations for things that are not installed). The
    # executable name that is used is the name of the configuration. In some cases, the
    # name of the configuration and the executable are different.
    #
    # For example: the helix editor binary is hx.
    executable: str


    # Directories that should be created before running stow to install the dotfiles.
    #
    # This is useful to ensure that stow creates symlinks to the files inside a
    # diectory and not a symlink to the directory itself.
    #
    # For example: to install the set of fish completions we ship with the dotfiles,
    # we need to ensure that `~/.config/fish/completions/` exists. Otherwise, when we
    # run stow, it will just symlink the completions folder, and all the completions we
    # install will appear in this repository.
    create_dirs: list[str]

    # A series of commands to run after running stow.
    #
    # For example, in fish, we want to update the plugins we install with fisher after
    # we have deployed the configurations so that the actual installed plugins, and the
    # manifest stay in sync.
    post_install: list[str]

REQUIRED_DIRS = [
    "~/.config/", "~/.local/share", "~/.local/bin",
]

STOWED_PROGRAMS: dict[str, ProgramConfiguration] = {
    "bash": {
    },
    "fish": {
        # We use `fisher` to install plugins, this will put the installed functions in
        # `functions`. This is also where we put our own functions. If we do not create
        # the directory, all of the plugin-installed functions will appear in our diff.
        "create_dirs": [
            "~/.config/fish/completions/",
            "~/.config/fish/functions/",
        ],
        # Ensure that the list of plugins is up-to-date
        "post_install": [
            "fish -c 'fisher update'"
        ]
    },
    "git": {},
    "gdb": {},
    "helix": {
        "executable": "hx",
    },
    "jrnl": {},
    "matlab": {},
    "vim": {},
    "sublime-text-3": {
        "executable": "subl",
        "create_dirs": [
            "~/.config/sublime-text-3/Packages/User",
        ],
    },
    "sublime-merge": {
        "executable": "smerge",
        "create_dirs": [
            "~/.config/sublime-merge/Packages/User",
        ],
    },
    "regolith": {
        "executable": "regolith-look",
        "create_dirs": [
            "~/.config/regolith3",
        ],
    },
    "tools": {
        # These scripts often depend on uv script mode to run
        "executable": "uv",
        "create_dirs": [
            "~/.local/share/reminders"
        ]
    },
}

g_targets_processed: list[str] = []


def is_installed(executable: str) -> bool:
    ret = subprocess.run(
        ["which", executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE
    )
    return not bool(ret.returncode)


def stow(target: str, config: ProgramConfiguration) -> tuple[bool, str, str]:
    global g_targets_processed
    if target in g_targets_processed:
        print(f"    <{target}> already processed, skipping.")
        return True, "", ""

    g_targets_processed.append(target)

    # Note: Universal newlines tells python to use the default system encoding for the
    # stdout/stderr messages
    command = ["stow", "--target", expanduser("~"), "--restow", target]
    ret = subprocess.run(
        command,
        text=True,
        capture_output=True
    )

    return not bool(ret.returncode), " ".join(command), ret.stdout + ret.stderr

@contextmanager
def action(name: str) -> Generator[None, None, None]:
    print(f"- {name} ".ljust(60, "."), end="")

    try:
        yield
    except Exception as exc:
        print(" \033[31mFAIL\033[0m")
        print(str(errmsg))
        sys.exit(-1)

    print(" \033[32mOK\033[0m")

if __name__ == "__main__":
    valid_targets_msg = f"\nValid targets are: {", ".join(STOWED_PROGRAMS.keys())}"

    parser = argparse.ArgumentParser(
        description=__doc__ + valid_targets_msg,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        "-f",
        "--force",
        action="store_true",
        help="Install configuration even if the associated executable is not installed",
    )
    parser.add_argument(
        "targets",
        metavar="TARGET",
        choices=[*STOWED_PROGRAMS.keys(), "all"],
        type=str,
        nargs="+",
        help="The configurations to install",
    )
    args = parser.parse_args()

    if "all" in args.targets:
        args.targets = [*STOWED_PROGRAMS.keys()]

    if not is_installed("stow"):
        print("Error: `stow` is not installed. Install `stow` to continue.")
        sys.exit(1)

    valid_targets = []
    for target in args.targets:
        if target in STOWED_PROGRAMS:
            executable_name = STOWED_PROGRAMS[target].get("executable", target)
            if not args.force and not is_installed(executable_name):
                print(
                    f"- Skipping <{target}>, <{executable_name}> is not in $PATH ".ljust(
                        60, "."
                    )
                    + " \033[31mFAIL\033[0m"
                )
                continue

            valid_targets.append(target)
        else:
            print(f"\033[31mERROR\033[0m: unknown target <{target}>.")

    # Create all the required directories before running
    for dir in [Path(p) for p in REQUIRED_DIRS]:
        if not dir.expanduser().is_dir():
            with action(f"Creating {dir}"):
                dir.expanduser().mkdir(parents=True)

    for target in valid_targets:
        if required_dirs := getattr(target, "create_dirs", None):
            if not isinstance(required_dirs, Iterable):
                required_dirs = [required_dirs]

            for dir in [Path(p) for p in required_dirs]:
                if not dir.expanduser().is_dir():
                    with action(f"Creating {dir}"):
                        dir.expanduser().mkdir(exist_ok=True, parents=True)

    for target in valid_targets:
        target_properties = STOWED_PROGRAMS[target]
        with action(f"Installing configurations for {target}"):
            ok, command, errmsg = stow(target, target_properties)

        if post_install := target_properties.get("post_install", None):
            with action(f"Running {post_install}"):
                subprocess.run(post_install, shell=True, check=True)

    sys.exit(0)
